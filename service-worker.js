(()=>{"use strict";var e={923:()=>{try{self["workbox:core:5.1.4"]&&_()}catch(e){}}},t={};function n(s){var o=t[s];if(void 0!==o)return o.exports;var r=t[s]={exports:{}};return e[s](r,r.exports,n),r.exports}(()=>{n(923);Error;new Set;"undefined"!==typeof registration&&registration.scope;class e{constructor(e,t,{onupgradeneeded:n,onversionchange:s}={}){this._db=null,this._name=e,this._version=t,this._onupgradeneeded=n,this._onversionchange=s||(()=>this.close())}get db(){return this._db}async open(){if(!this._db)return this._db=await new Promise(((e,t)=>{let n=!1;setTimeout((()=>{n=!0,t(new Error("The open request was blocked and timed out"))}),this.OPEN_TIMEOUT);const s=indexedDB.open(this._name,this._version);s.onerror=()=>t(s.error),s.onupgradeneeded=e=>{n?(s.transaction.abort(),s.result.close()):"function"===typeof this._onupgradeneeded&&this._onupgradeneeded(e)},s.onsuccess=()=>{const t=s.result;n?t.close():(t.onversionchange=this._onversionchange.bind(this),e(t))}})),this}async getKey(e,t){return(await this.getAllKeys(e,t,1))[0]}async getAll(e,t,n){return await this.getAllMatching(e,{query:t,count:n})}async getAllKeys(e,t,n){return(await this.getAllMatching(e,{query:t,count:n,includeKeys:!0})).map((e=>e.key))}async getAllMatching(e,{index:t,query:n=null,direction:s="next",count:o,includeKeys:r=!1}={}){return await this.transaction([e],"readonly",((a,i)=>{const c=a.objectStore(e),l=t?c.index(t):c,d=[],u=l.openCursor(n,s);u.onsuccess=()=>{const e=u.result;e?(d.push(r?e:e.value),o&&d.length>=o?i(d):e.continue()):i(d)}}))}async transaction(e,t,n){return await this.open(),await new Promise(((s,o)=>{const r=this._db.transaction(e,t);r.onabort=()=>o(r.error),r.oncomplete=()=>s(),n(r,(e=>s(e)))}))}async _call(e,t,n,...s){return await this.transaction([t],n,((n,o)=>{const r=n.objectStore(t),a=r[e].apply(r,s);a.onsuccess=()=>o(a.result)}))}close(){this._db&&(this._db.close(),this._db=null)}}e.prototype.OPEN_TIMEOUT=2e3;const t={readonly:["get","count","getKey","getAll","getAllKeys"],readwrite:["add","put","clear","delete"]};for(const[n,s]of Object.entries(t))for(const t of s)t in IDBObjectStore.prototype&&(e.prototype[t]=async function(e,...s){return await this._call(t,e,n,...s)});[{'revision':'c632ff308b88eebf0cf8a138a61be13a','url':'/memlog/index.html'},{'revision':null,'url':'/memlog/static/css/main.1a7488ce.css'},{'revision':null,'url':'/memlog/static/js/377.81b25707.chunk.js'},{'revision':null,'url':'/memlog/static/js/main.944b6470.js'}];self.addEventListener("activate",(()=>self.clients.claim())),self.addEventListener("message",(e=>{e.data&&"SKIP_WAITING"===e.data.type&&self.skipWaiting()}));setInterval((()=>{self.clients.matchAll().then((e=>{e.forEach((e=>e.postMessage({type:"ping",data:Date.now()})))}))}),2e4),setImmediate((()=>{((e,...t)=>{self.clients.matchAll().then((n=>{n.forEach((n=>n.postMessage({type:"log",data:{message:e,data:t}})))}))})("worker setup")}))})()})();
//# sourceMappingURL=service-worker.js.map